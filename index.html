<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clipboard Magic · Logger</title>
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-a: #090e1d;
      --bg-b: #0c1630;
      --panel: rgba(255, 255, 255, 0.06);
      --card: rgba(255, 255, 255, 0.08);
      --line: rgba(255, 255, 255, 0.12);
      --text: #e7edf7;
      --muted: #9fb3c8;
      --accent: #67e8f9;
      --accent-2: #f97316;
      --shadow: 0 30px 70px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 10% 20%, rgba(103, 232, 249, 0.12), transparent 28%),
                  radial-gradient(circle at 85% 0%, rgba(249, 115, 22, 0.16), transparent 32%),
                  linear-gradient(145deg, var(--bg-a), var(--bg-b));
      color: var(--text);
      font-family: "Sora", "SF Pro Display", "Inter", system-ui, -apple-system, sans-serif;
      padding: 28px;
      display: flex;
      justify-content: center;
    }

    .shell {
      width: min(1200px, 100%);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      overflow: hidden;
    }

    .hero {
      padding: 26px 26px 20px;
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 18px;
      background: linear-gradient(120deg, rgba(103, 232, 249, 0.18), rgba(255, 255, 255, 0)) border-box;
      border-bottom: 1px solid var(--line);
    }

    .eyebrow {
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 6px;
    }

    h1 {
      margin: 0 0 10px;
      font-size: clamp(26px, 3vw, 34px);
      letter-spacing: -0.02em;
    }

    .muted {
      color: var(--muted);
      margin: 0;
      font-size: 14px;
      line-height: 1.6;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 14px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid var(--line);
      border-radius: 999px;
      font-size: 12px;
      color: var(--text);
    }

    .chip.on {
      background: rgba(103, 232, 249, 0.16);
      border-color: rgba(103, 232, 249, 0.6);
    }

    .chip.soft {
      background: rgba(255, 255, 255, 0.05);
      color: var(--muted);
    }

    button.chip {
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      cursor: pointer;
    }

    .status-card {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 16px;
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .status-label {
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.1em;
      color: var(--muted);
    }

    .status-text {
      font-size: 15px;
      color: var(--text);
      line-height: 1.4;
      min-height: 36px;
    }

    .status-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .layout {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 18px;
      padding: 20px 20px 24px;
    }

    @media (max-width: 1200px) {
      body {
        padding: 22px;
      }
      .hero {
        grid-template-columns: 1fr 1fr;
      }
      .layout {
        grid-template-columns: 320px 1fr;
        gap: 16px;
      }
      .shell {
        border-radius: 16px;
      }
    }

    @media (max-width: 1000px) {
      body {
        padding: 18px;
      }
      .layout {
        grid-template-columns: 1fr;
        padding: 16px;
        gap: 14px;
      }
    }

    @media (max-width: 900px) {
      .hero {
        grid-template-columns: 1fr;
        padding: 18px 18px 16px;
      }
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .card-head {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    h2 {
      margin: 0;
      font-size: 18px;
      letter-spacing: -0.01em;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    label.field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    .input {
      padding: 12px 14px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--line);
      border-radius: 10px;
      color: var(--text);
      font-size: 14px;
      outline: none;
      transition: border-color 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
    }

    .input:focus {
      border-color: rgba(103, 232, 249, 0.6);
      box-shadow: 0 0 0 4px rgba(103, 232, 249, 0.12);
      transform: translateY(-1px);
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      color: #061325;
      background: linear-gradient(135deg, var(--accent), #4ade80);
      transition: transform 0.1s ease, box-shadow 0.2s ease, filter 0.2s ease;
      box-shadow: 0 12px 26px rgba(103, 232, 249, 0.25);
      font-size: 14px;
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.03);
    }

    button:active {
      transform: translateY(0);
    }

    button.ghost {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border: 1px solid var(--line);
      box-shadow: none;
    }

    button.danger {
      border-color: rgba(249, 115, 22, 0.6);
      color: #f5d0c5;
    }

    .helper {
      font-size: 13px;
      color: var(--muted);
      background: rgba(255, 255, 255, 0.05);
      border: 1px dashed var(--line);
      border-radius: 10px;
      padding: 10px;
    }

    .logs {
      gap: 16px;
    }

    .log-list {
      display: grid;
      gap: 12px;
    }

    @media (max-width: 768px) {
      body {
        padding: 14px;
      }
      .shell {
        border-radius: 14px;
      }
      .hero {
        padding: 16px;
        gap: 12px;
      }
      .card {
        padding: 14px;
        gap: 12px;
      }
      .chips {
        gap: 8px;
      }
      .status-actions,
      .row,
      .chips,
      .log-actions {
        flex-direction: column;
        align-items: stretch;
      }
      .status-actions button,
      .row button,
      .log-actions button,
      #format-mode-chips button {
        width: 100%;
        justify-content: center;
      }
      .image-thumb {
        max-height: 200px;
      }
      .mini-pretty {
        max-height: 120px;
      }
    }

    @media (max-width: 560px) {
      h1 {
        font-size: 23px;
      }
      h2 {
        font-size: 16px;
      }
      .hero {
        padding: 14px;
      }
      .card {
        padding: 12px;
      }
      .status-card {
        padding: 12px;
      }
      .chips {
        gap: 6px;
      }
      .image-thumb {
        max-height: 180px;
      }
    }

    @media (max-width: 420px) {
      h1 {
        font-size: 21px;
      }
      h2 {
        font-size: 15px;
      }
      .hero {
        padding: 12px;
      }
      .card {
        padding: 10px;
      }
      .status-card {
        padding: 10px;
      }
      button {
        padding: 10px 12px;
      }
    }

    .log-card {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 14px;
      background: rgba(255, 255, 255, 0.04);
      display: grid;
      gap: 10px;
    }

    .log-top {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .log-meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .log-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .log-body {
      width: 100%;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      color: var(--text);
      font-family: "Sora", "SF Pro Display", "Inter", system-ui, -apple-system, sans-serif;
      font-size: 14px;
      resize: vertical;
      min-height: 80px;
    }

    .log-body:disabled {
      opacity: 0.9;
    }

    .mini-preview {
      background: rgba(255, 255, 255, 0.04);
      border: 1px dashed var(--line);
      border-radius: 10px;
      padding: 10px;
      color: var(--muted);
      font-size: 13px;
    }

    .mini-preview ul {
      margin: 6px 0 0;
      padding-left: 18px;
      color: var(--text);
      display: grid;
      gap: 4px;
    }

    .mini-preview .label {
      font-weight: 600;
      color: var(--text);
      font-size: 13px;
    }

    .mini-pretty {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
      font-size: 12px;
      color: var(--text);
      overflow: auto;
      max-height: 200px;
      white-space: pre;
    }

    .image-box {
      display: grid;
      gap: 8px;
    }

    .image-thumb {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      max-height: 280px;
      overflow: hidden;
    }

    .image-thumb img {
      width: 100%;
      max-height: 260px;
      object-fit: contain;
      border-radius: 8px;
    }

    .image-meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--muted);
    }

    .empty {
      padding: 16px;
      border: 1px dashed var(--line);
      border-radius: 10px;
      color: var(--muted);
      text-align: center;
    }

    .toast {
      position: fixed;
      right: 18px;
      bottom: 18px;
      background: #0f172a;
      border: 1px solid var(--line);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      display: flex;
      gap: 8px;
      align-items: center;
      opacity: 0;
      transform: translateY(12px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      min-width: 220px;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    #toast-title {
      font-weight: 700;
    }

    #toast-detail {
      color: var(--muted);
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="shell">
    <header class="hero">
      <div>
        <p class="eyebrow">Clipboard Magic · Logger</p>
        <h1>Auto-log your clipboard, smart-format text, render images, and CRUD the history.</h1>
        <p class="muted">Copy anything—text, JSON, Markdown, HTML, CSV, or images. We detect the type, prettify it, and keep an editable history with copy/download controls.</p>
        <div class="chips">
          <span class="chip" id="auto-chip">Auto log off</span>
          <span class="chip" id="format-chip">Format: Auto</span>
          <span class="chip" id="category-chip">Category: General</span>
          <span class="chip soft">CRUD: add / edit / delete / copy</span>
          <span class="chip soft" id="storage-chip">Storage: checking…</span>
        </div>
      </div>
      <div class="status-card">
        <div class="status-label">Status</div>
        <div class="status-text" id="status-text">Waiting to read your clipboard…</div>
        <div class="status-actions">
          <button id="log-once">Log clipboard now</button>
          <button id="toggle-auto" class="ghost">Start auto log</button>
        </div>
      </div>
    </header>

    <div class="layout">
      <section class="card controls">
        <div class="card-head">
          <div>
            <h2>Smart formatter</h2>
            <p class="muted">Auto-detect JSON, Markdown, HTML, CSV, or force a mode. Copies get prettified on the way in.</p>
          </div>
        </div>
        <div class="chips" id="format-mode-chips" style="gap:8px;">
          <button class="chip ghost" data-mode="auto">Auto</button>
          <button class="chip ghost" data-mode="json">JSON</button>
          <button class="chip ghost" data-mode="markdown">Markdown</button>
          <button class="chip ghost" data-mode="html">HTML</button>
          <button class="chip ghost" data-mode="csv">CSV</button>
          <button class="chip ghost" data-mode="plain">Plain bullets</button>
          <button class="chip ghost" data-mode="none">No formatting</button>
        </div>
        <label class="field">
          Default category for new logs
          <input id="category-input" class="input" placeholder="General" aria-label="Default category" list="category-options">
        </label>
        <div class="row">
          <button id="save-category">Save category</button>
          <button id="log-once-secondary" class="ghost">Log clipboard now</button>
          <button id="clear-logs" class="ghost danger">Clear all logs</button>
        </div>
        <div class="row">
          <div class="helper" style="flex:1;">Tip: leave on Auto to detect type. Force JSON/Markdown/HTML/CSV if you want a specific transform.</div>
        </div>
      </section>

      <section class="card logs">
        <div class="card-head">
          <div>
            <h2>Clipboard log</h2>
            <p class="muted">Auto entries stay here so you can copy, edit, or delete them.</p>
          </div>
          <div class="row">
            <span class="chip soft" id="log-count">0 items</span>
          </div>
        </div>
        <div id="log-list" class="log-list"></div>
      </section>
    </div>
  </div>

  <div class="toast" id="toast">
    <span id="toast-title"></span>
    <span id="toast-detail"></span>
  </div>
  <datalist id="category-options"></datalist>

  <script>
    const LOGS_KEY = "clipboard-magic-logs";
    const MAX_CHARS = 8000;
    const MAX_IMAGE_BYTES = 1200000; // ~1.2MB raw
    const MAX_B64_STORAGE = 600000; // cap per-entry size for localStorage
    const FORMAT_KEY = "clipboard-magic-format-mode";
    const CATEGORY_KEY = "clipboard-magic-category";
    const logOnceBtn = document.getElementById("log-once");
    const logOnceSecondaryBtn = document.getElementById("log-once-secondary");
    const toggleAutoBtn = document.getElementById("toggle-auto");
    const clearLogsBtn = document.getElementById("clear-logs");
    const logList = document.getElementById("log-list");
    const logCount = document.getElementById("log-count");
    const autoChip = document.getElementById("auto-chip");
    const formatChip = document.getElementById("format-chip");
    const categoryChip = document.getElementById("category-chip");
    const categoryInput = document.getElementById("category-input");
    const saveCategoryBtn = document.getElementById("save-category");
    const categoryOptions = document.getElementById("category-options");
    const storageChip = document.getElementById("storage-chip");
    const statusText = document.getElementById("status-text");
    const toast = document.getElementById("toast");
    const toastTitle = document.getElementById("toast-title");
    const toastDetail = document.getElementById("toast-detail");
    const formatModeChips = document.getElementById("format-mode-chips");

    let logs = [];
    let autoTimer = null;
    let lastSnapshotSig = "";
    let lastErrorAt = 0;
    let storageOk = true;
    let storageWarned = false;
    let defaultCategory = "General";

    function modeLabel(mode) {
      switch (mode) {
        case "json":
          return "JSON";
        case "markdown":
          return "Markdown";
        case "html":
          return "HTML";
        case "csv":
          return "CSV";
        case "plain":
          return "Plain";
        case "none":
          return "No formatting";
        default:
          return mode === "auto" ? "Auto" : "Plain";
      }
    }

    function formatLabel(mode) {
      return modeLabel(mode);
    }

    function init() {
      storageOk = storageAvailable();
      updateStorageChip();
      logs = storageOk ? (safeParse(localStorage.getItem(LOGS_KEY)) || []).map(normalizeLog) : [];
      defaultCategory = storageOk ? localStorage.getItem(CATEGORY_KEY) || "General" : "General";
      categoryInput.value = defaultCategory;
      renderLogs();
      updateFormatChip();
      updateCategoryChip();
      updateCategoryOptions();
      updateCounts();
      bindEvents();
      statusText.textContent = storageOk
        ? "Ready. Storage: local. Use the buttons to log your clipboard."
        : "Ready. Storage: in-memory only. Use the buttons to log your clipboard.";
      if (!storageOk) {
        flashToast("Storage unavailable", "Running in-memory only");
      }
    }

    function bindEvents() {
      logOnceBtn.addEventListener("click", () => captureClipboard({ source: "manual", force: true }));
      logOnceSecondaryBtn.addEventListener("click", () => captureClipboard({ source: "manual", force: true }));
      toggleAutoBtn.addEventListener("click", toggleAuto);
      clearLogsBtn.addEventListener("click", clearLogs);
      logList.addEventListener("click", onLogAction);
      formatModeChips.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-mode]");
        if (!btn) return;
        setFormatMode(btn.dataset.mode);
      });
      saveCategoryBtn.addEventListener("click", saveDefaultCategory);
      categoryInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          saveDefaultCategory();
        }
      });
    }

    function saveDefaultCategory() {
      const value = (categoryInput.value || "").trim() || "General";
      defaultCategory = value;
      if (storageOk) {
        try {
          localStorage.setItem(CATEGORY_KEY, value);
        } catch (error) {
          markStorageIssue();
        }
      }
      updateCategoryChip();
      updateCategoryOptions();
      flashToast("Default category saved", value);
    }

    function getFormatMode() {
      if (!storageOk) return "auto";
      const value = localStorage.getItem(FORMAT_KEY);
      return value || "auto";
    }

    function setFormatMode(mode) {
      const allowed = ["auto", "json", "markdown", "html", "csv", "plain", "none"];
      const next = allowed.includes(mode) ? mode : "auto";
      if (storageOk) {
        try {
          localStorage.setItem(FORMAT_KEY, next);
        } catch (error) {
          markStorageIssue();
        }
      }
      updateFormatChip();
      highlightMode(next);
      flashToast("Format mode set", modeLabel(next));
    }

    function highlightMode(mode) {
      Array.from(formatModeChips.querySelectorAll("button[data-mode]")).forEach((btn) => {
        btn.classList.toggle("on", btn.dataset.mode === mode);
        btn.classList.toggle("ghost", btn.dataset.mode !== mode);
      });
    }

    function updateFormatChip() {
      const mode = getFormatMode();
      formatChip.textContent = "Format: " + modeLabel(mode);
      highlightMode(mode);
    }

    function updateCategoryChip() {
      categoryChip.textContent = "Category: " + defaultCategory;
    }

    function updateStorageChip() {
      storageChip.textContent = storageOk ? "Storage: local" : "Storage: in-memory";
      storageChip.classList.toggle("on", storageOk);
    }

    function toggleAuto() {
      if (autoTimer) {
        stopAuto();
        return;
      }
      if (!navigator.clipboard || !navigator.clipboard.readText) {
        flashToast("Clipboard API unavailable", "Use manual log instead");
        return;
      }
      captureClipboard({ source: "auto", force: true });
      autoTimer = setInterval(() => captureClipboard({ source: "auto" }), 3500);
      autoChip.textContent = "Auto log on";
      autoChip.classList.add("on");
      toggleAutoBtn.textContent = "Stop auto log";
      statusText.textContent = "Auto logging every ~3.5s…";
      flashToast("Auto log on", "New clipboard items will be captured");
    }

    function stopAuto() {
      clearInterval(autoTimer);
      autoTimer = null;
      autoChip.textContent = "Auto log off";
      autoChip.classList.remove("on");
      toggleAutoBtn.textContent = "Start auto log";
      statusText.textContent = "Auto log is off.";
      flashToast("Auto log off", "");
    }

    function clearLogs() {
      logs.forEach(cleanupEntry);
      logs = [];
      persistLogs();
      renderLogs();
      flashToast("Logs cleared", "");
    }

    function onLogAction(event) {
      const btn = event.target.closest("button");
      if (!btn) return;
      const id = btn.dataset.id;
      const action = btn.dataset.action;
      const entry = logs.find((l) => l.id === id);
      if (!entry) return;

      if (action === "copy") {
        copyEntry(entry);
        return;
      }
      if (action === "delete") {
        cleanupEntry(entry);
        logs = logs.filter((l) => l.id !== id);
        persistLogs();
        renderLogs();
        flashToast("Entry deleted", "");
        return;
      }
      if (action === "download") {
        downloadEntry(entry);
        return;
      }
      if (action === "edit") {
        if ((entry.kind || "text") !== "text") {
          return;
        }
        toggleEdit(btn, entry);
        return;
      }
      if (action === "set-category") {
        const card = btn.closest(".log-card");
        const input = card ? card.querySelector(`input[data-category-input][data-id="${id}"]`) : null;
        const value = input ? input.value : btn.dataset.value || "";
        setEntryCategory(id, value);
        return;
      }
    }

    function toggleEdit(btn, entry) {
      const card = btn.closest(".log-card");
      const textarea = card.querySelector("textarea");
      const mode = btn.dataset.mode || "edit";
      if (mode === "edit") {
        btn.dataset.mode = "save";
        btn.textContent = "Save";
        textarea.disabled = false;
        textarea.focus();
        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        return;
      }
      const updatedText = textarea.value;
      updateEntry(entry.id, updatedText);
      btn.dataset.mode = "edit";
      btn.textContent = "Edit";
    }

    async function copyEntry(entry) {
      const kind = entry.kind || "text";
      if (kind === "image") {
        return copyImage(entry);
      }
      const formatted = Array.isArray(entry.formatted) ? entry.formatted : [];
      const text = entry.pretty
        ? entry.pretty
        : formatted.length
          ? formatted.map((i) => "• " + i).join("\n")
          : entry.raw || "";
      try {
        await navigator.clipboard.writeText(text);
        flashToast("Copied", text.slice(0, 60));
      } catch (error) {
        flashToast("Clipboard blocked", "Allow write access");
      }
    }

    function updateEntry(id, raw) {
      const limited = limitText(raw);
      logs = logs.map((item) => {
        if (item.id !== id) return item;
        const trimmed = limited.text;
        const transform = transformText(trimmed);
        return {
          ...item,
          raw: trimmed,
          formatted: transform.formatted,
          pretty: transform.pretty,
          formatType: transform.formatType,
          updatedAt: new Date().toISOString(),
        };
      });
      persistLogs();
      renderLogs();
      flashToast(limited.truncated ? "Entry trimmed and saved" : "Entry updated", limited.text.slice(0, 60));
    }

    function setEntryCategory(id, category) {
      const value = (category || defaultCategory || "General").trim() || "General";
      logs = logs.map((item) => (item.id === id ? { ...item, category: value } : item));
      persistLogs();
      renderLogs();
      flashToast("Category updated", value);
    }

    function makeId() {
      return crypto.randomUUID ? crypto.randomUUID() : "id-" + Date.now() + "-" + Math.random().toString(16).slice(2);
    }

    function addTextLog(raw, source) {
      const limited = limitText(raw);
      const trimmed = limited.text;
      if (!trimmed) {
        flashToast("Clipboard empty", "");
        return;
      }

      const transform = transformText(trimmed);
      const entry = {
        id: makeId(),
        kind: "text",
        raw: trimmed,
        formatted: transform.formatted,
        pretty: transform.pretty,
        formatType: transform.formatType,
        category: defaultCategory,
        source: source || "clipboard",
        createdAt: new Date().toISOString(),
      };
      pushLog(entry);
      lastSnapshotSig = "text:" + trimmed;
      persistLogs();
      renderLogs();
      const label = transform.formatType ? modeLabel(transform.formatType) : "Captured";
      const title = limited.truncated ? "Logged (trimmed)" : "Logged " + (source || "clipboard");
      flashToast(title, limited.truncated ? "Saved first " + MAX_CHARS + " chars" : label);
    }

    async function addImageLog(blob, mime, source) {
      const tooLarge = blob.size > MAX_IMAGE_BYTES;
      let dataUrl = null;
      let objectUrl = null;
      let conversionFailed = false;
      if (!tooLarge) {
        try {
          dataUrl = await blobToDataUrl(blob);
        } catch (error) {
          conversionFailed = true;
          objectUrl = URL.createObjectURL(blob);
        }
      } else {
        objectUrl = URL.createObjectURL(blob);
      }
      const inMemoryOnly = !storageOk || tooLarge || conversionFailed || (dataUrl && dataUrl.length > MAX_B64_STORAGE);
      const entry = {
        id: makeId(),
        kind: "image",
        mime,
        size: blob.size,
        dataUrl,
        objectUrl,
        inMemoryOnly,
        category: defaultCategory,
        source: source || "clipboard",
        createdAt: new Date().toISOString(),
      };
      pushLog(entry);
      lastSnapshotSig = "image:" + mime + ":" + blob.size;
      persistLogs();
      renderLogs();
      if (tooLarge) {
        flashToast("Image logged in-memory", "Too large to persist (> " + prettySize(MAX_IMAGE_BYTES) + ")");
      } else if (conversionFailed) {
        flashToast("Image logged in-memory", "Preview limited due to conversion issue");
      } else if (entry.inMemoryOnly) {
        flashToast("Image logged (session only)", "Kept under size budget");
      } else {
        flashToast("Image logged", mime + " · " + prettySize(blob.size));
      }
    }

    async function captureClipboard(options = {}) {
      const { source = "clipboard", force = false } = options;
      if (!navigator.clipboard) {
        flashToast("Clipboard API unavailable", "Use a modern browser or localhost/https");
        return;
      }

      try {
        if (navigator.clipboard.read) {
          const items = await navigator.clipboard.read();
          let processed = false;
          for (const item of items) {
            const imageType = item.types.find((t) => t.startsWith("image/"));
            if (imageType) {
              const blob = await item.getType(imageType);
              const sig = "image:" + imageType + ":" + blob.size;
              if (!force && autoTimer && sig === lastSnapshotSig) {
                return;
              }
              lastSnapshotSig = sig;
              await addImageLog(blob, imageType, source);
              statusText.textContent = "Captured image at " + timeString(new Date().toISOString());
              processed = true;
              break;
            }
            if (item.types.includes("text/plain")) {
              const blob = await item.getType("text/plain");
              const text = await blob.text();
              const sig = "text:" + text.trim();
              if (!force && autoTimer && sig === lastSnapshotSig) {
                return;
              }
              lastSnapshotSig = sig;
              if (!text.trim()) {
                statusText.textContent = "Clipboard is empty.";
                return;
              }
              statusText.textContent = "Captured text at " + timeString(new Date().toISOString());
              addTextLog(text, source);
              processed = true;
              break;
            }
          }
          if (!processed) {
            statusText.textContent = "Clipboard has unsupported data.";
            flashToast("Unsupported clipboard data", "");
          }
          return;
        }

        const text = await navigator.clipboard.readText();
        const sig = "text:" + text.trim();
        if (!force && autoTimer && sig === lastSnapshotSig) {
          return;
        }
        if (!text) {
          statusText.textContent = "Clipboard is empty.";
          return;
        }
        lastSnapshotSig = sig;
        statusText.textContent = "Captured text at " + timeString(new Date().toISOString());
        addTextLog(text, source);
      } catch (error) {
        statusText.textContent = "Clipboard blocked; auto-log is still on. Keep this tab active or allow access.";
        const now = Date.now();
        if (now - lastErrorAt > 3500) {
          flashToast("Clipboard blocked", "Auto-log keeps trying; allow permission");
          lastErrorAt = now;
        }
      }
    }

    function limitText(raw) {
      const trimmed = (raw || "").trim();
      const truncated = trimmed.length > MAX_CHARS;
      return {
        text: truncated ? trimmed.slice(0, MAX_CHARS) : trimmed,
        truncated,
      };
    }

    function pushLog(entry) {
      const next = [entry, ...logs];
      if (next.length > 80) {
        next.slice(80).forEach(cleanupEntry);
      }
      logs = next.slice(0, 80);
    }

    function transformText(raw) {
      const mode = getFormatMode();
      const target = mode === "auto" ? detectFormat(raw) : mode;

      if (target === "json") {
        try {
          const parsed = JSON.parse(raw);
          const pretty = JSON.stringify(parsed, null, 2);
          const summary = summarizeJson(parsed);
          return { formatType: "json", formatted: summary, pretty };
        } catch (error) {
          return { formatType: "json", formatted: bulletize(raw), pretty: raw };
        }
      }

      if (target === "markdown") {
        const stripped = stripMarkdown(raw);
        return { formatType: "markdown", formatted: bulletize(stripped), pretty: stripped };
      }

      if (target === "html") {
        const text = stripHtml(raw);
        const compact = text.replace(/\s+/g, " ").trim();
        return { formatType: "html", formatted: bulletize(text), pretty: compact || raw };
      }

      if (target === "csv") {
        const preview = csvPreview(raw);
        return { formatType: "csv", formatted: preview, pretty: raw };
      }

      if (target === "plain") {
        return { formatType: "plain", formatted: bulletize(raw), pretty: raw };
      }

      if (target === "none") {
        return { formatType: "none", formatted: [], pretty: raw };
      }

      return { formatType: target, formatted: bulletize(raw), pretty: raw };
    }

    function detectFormat(text) {
      if (!text) return "plain";
      const trimmed = text.trim();
      if (looksLikeJson(trimmed)) return "json";
      if (looksLikeHtml(trimmed)) return "html";
      if (looksLikeCsv(trimmed)) return "csv";
      if (looksLikeMarkdown(trimmed)) return "markdown";
      return "plain";
    }

    function looksLikeJson(text) {
      if (!text || text.length < 2) return false;
      const starts = text[0];
      const ends = text[text.length - 1];
      if (!((starts === "{" && ends === "}") || (starts === "[" && ends === "]"))) return false;
      try {
        JSON.parse(text);
        return true;
      } catch (error) {
        return false;
      }
    }

    function looksLikeHtml(text) {
      return /<[^>]+>/.test(text) && /<\/[^>]+>/.test(text);
    }

    function looksLikeMarkdown(text) {
      return /^#{1,6}\s|\n-{3,}|\n\* |\n- |\n\d+\.\s|`{3}/m.test(text) || /\[.+\]\(.+\)/.test(text);
    }

    function looksLikeCsv(text) {
      const lines = text.trim().split(/\n/);
      if (lines.length < 2) return false;
      const first = lines[0].split(",").length;
      const second = lines[1].split(",").length;
      return first > 1 && second > 1 && Math.abs(first - second) <= 2;
    }

    function bulletize(raw) {
      const cleaned = (raw || "").replace(/\s+/g, " ").trim();
      if (!cleaned) return [];
      return cleaned
        .split(/[.;\n]+/)
        .map((item) => item.trim())
        .filter(Boolean)
        .map(titleCase);
    }

    function titleCase(str) {
      return str.replace(/\w\S*/g, (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase());
    }

    function stripMarkdown(text) {
      return (text || "")
        .replace(/!\[[^\]]*\]\([^)]*\)/g, "")
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1")
        .replace(/`{3}[\s\S]*?`{3}/g, "")
        .replace(/`([^`]+)`/g, "$1")
        .replace(/[*_]{1,2}([^*_]+)[*_]{1,2}/g, "$1")
        .replace(/^#{1,6}\s+/gm, "")
        .replace(/^-{3,}$/gm, "")
        .replace(/^\s*[-*+]\s+/gm, "")
        .replace(/^\s*\d+\.\s+/gm, "")
        .trim();
    }

    function stripHtml(text) {
      return (text || "").replace(/<script[\s\S]*?<\/script>/gi, "").replace(/<style[\s\S]*?<\/style>/gi, "").replace(/<[^>]+>/g, " ");
    }

    function summarizeJson(value) {
      if (Array.isArray(value)) {
        return ["Array: " + value.length + " items"];
      }
      if (value && typeof value === "object") {
        return Object.keys(value).map((key) => `${key}: ${typeof value[key]}`);
      }
      return [String(value)];
    }

    function csvPreview(text) {
      const lines = text.trim().split(/\n/).slice(0, 5);
      const preview = [];
      lines.forEach((line, idx) => {
        const cells = line.split(",").map((c) => c.trim());
        preview.push(`Row ${idx + 1}: ${cells.join(" | ")}`);
      });
      return preview;
    }

    function renderLogs() {
      if (!logs.length) {
        logList.innerHTML = '<div class="empty">No entries yet. Copy text, hit "Log clipboard now", or enable auto-log.</div>';
        updateCounts();
        updateCategoryOptions();
        return;
      }
      logList.innerHTML = logs
        .map((log) => renderLogCard(log))
        .join("");
      updateCounts();
      updateCategoryOptions();
    }

    function renderLogCard(log) {
      const kind = log.kind || "text";
      const created = timeString(log.createdAt);
      const sourceChip = `<span class="chip soft">${log.source || "clipboard"}</span>`;
      const category = escapeHTML(log.category || defaultCategory || "General");
      const categoryInputRow = `
        <div class="row" style="align-items:flex-end;">
          <label class="field" style="flex:1; min-width: 160px;">
            Category
            <input class="input" data-id="${log.id}" data-kind="${kind}" data-category-input list="category-options" value="${category}">
          </label>
          <button data-action="set-category" data-id="${log.id}" data-value="${category}">Update</button>
        </div>
      `;

      if (kind === "image") {
        const imgSrc = log.dataUrl || log.objectUrl;
        const sizeLabel = log.size ? prettySize(log.size) : "image";
        const persistChip = log.inMemoryOnly ? '<span class="chip soft">Session only</span>' : "";
        const actions = `
          <button data-action="copy" data-id="${log.id}">Copy image</button>
          <button data-action="download" data-id="${log.id}" class="ghost">Download</button>
          <button data-action="delete" data-id="${log.id}" class="ghost danger">Delete</button>
        `;
        return `
          <article class="log-card" data-id="${log.id}">
            <div class="log-top">
              <div class="log-meta">
                <span class="chip on">Image</span>
              <span class="chip soft">${created}</span>
              ${sourceChip}
              ${persistChip}
              <span class="chip soft">Category: ${category}</span>
            </div>
            <div class="log-actions">
              ${actions}
            </div>
          </div>
            <div class="image-box">
              <div class="image-thumb">
                ${imgSrc ? `<img src="${imgSrc}" alt="Clipboard image">` : '<div class="muted">No preview available</div>'}
              </div>
              <div class="image-meta">
                <span>${log.mime || "image"}</span>
                <span>·</span>
                <span>${sizeLabel}</span>
                ${log.inMemoryOnly ? "<span>· session only (size limit)</span>" : ""}
              </div>
              ${categoryInputRow}
            </div>
          </article>
        `;
      }

      const label = formatLabel(log.formatType || "plain");
      const chipClass = "chip on";
      const formatted = Array.isArray(log.formatted) ? log.formatted : [];
      const preview = formatted.length
        ? "<ul>" + formatted.map((item) => "<li>" + escapeHTML(item) + "</li>").join("") + "</ul>"
        : '<div class="muted">No preview yet. Try another format.</div>';
      const pretty = log.pretty && ["json", "html", "markdown", "csv"].includes(log.formatType || "")
        ? `<div class="mini-pretty">${escapeHTML(log.pretty)}</div>`
        : "";
      return `
        <article class="log-card" data-id="${log.id}">
          <div class="log-top">
            <div class="log-meta">
              <span class="${chipClass}">${label}</span>
              <span class="chip soft">${created}</span>
              ${sourceChip}
              <span class="chip soft">Category: ${category}</span>
            </div>
            <div class="log-actions">
              <button data-action="copy" data-id="${log.id}">Copy</button>
              <button data-action="edit" data-mode="edit" data-id="${log.id}" class="ghost">Edit</button>
              <button data-action="delete" data-id="${log.id}" class="ghost danger">Delete</button>
            </div>
          </div>
          <textarea class="log-body" data-id="${log.id}" disabled>${escapeHTML(log.raw || "")}</textarea>
          <div class="mini-preview">
            <div class="label">Preview</div>
            ${preview}
            ${pretty}
          </div>
          ${categoryInputRow}
        </article>
      `;
    }

    function timeString(iso) {
      const date = new Date(iso);
      return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
    }

    function persistLogs() {
      if (!storageOk) return;
      try {
        const toStore = logs.filter((l) => !l.inMemoryOnly).map(stripTransient);
        localStorage.setItem(LOGS_KEY, JSON.stringify(toStore));
      } catch (error) {
        if (logs.length > 10) {
          const keepCount = Math.max(10, Math.floor(logs.length * 0.75));
          const removed = logs.slice(keepCount);
          removed.forEach(cleanupEntry);
          logs = logs.slice(0, keepCount);
          try {
            const toStore = logs.filter((l) => !l.inMemoryOnly).map(stripTransient);
            localStorage.setItem(LOGS_KEY, JSON.stringify(toStore));
            flashToast("Storage trimmed", "Kept the most recent entries");
            renderLogs();
            return;
          } catch (err) {
            markStorageIssue();
          }
        } else {
          markStorageIssue();
        }
      }
    }

    function updateCounts() {
      logCount.textContent = logs.length + (logs.length === 1 ? " item" : " items");
    }

    function updateCategoryOptions() {
      const set = new Set();
      if (defaultCategory) set.add(defaultCategory);
      logs.forEach((l) => {
        if (l.category) set.add(l.category);
      });
      categoryOptions.innerHTML = Array.from(set)
        .slice(0, 30)
        .map((c) => `<option value="${escapeHTML(c)}"></option>`)
        .join("");
    }

    function flashToast(title, detail) {
      toastTitle.textContent = title;
      toastDetail.textContent = detail || "";
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 2000);
    }

    function safeParse(value) {
      try {
        return JSON.parse(value);
      } catch (error) {
        return [];
      }
    }

    function escapeHTML(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function stripTransient(entry) {
      const copy = { ...entry };
      delete copy.objectUrl;
      delete copy.inMemoryOnly;
      if (copy.pretty && copy.pretty.length > MAX_B64_STORAGE) {
        delete copy.pretty;
      }
      if (!copy.category) {
        copy.category = defaultCategory || "General";
      }
      return copy;
    }

    function normalizeLog(entry) {
      const kind = entry.kind || "text";
      const formatted = Array.isArray(entry.formatted) ? entry.formatted : [];
      const formatType = entry.formatType || (entry.matched ? "plain" : "plain");
      const category = entry.category || "General";
      return { ...entry, kind, formatted, formatType, category };
    }

    function prettySize(bytes) {
      if (!bytes && bytes !== 0) return "";
      if (bytes < 1024) return bytes + " B";
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
      return (bytes / (1024 * 1024)).toFixed(2) + " MB";
    }

    async function blobToDataUrl(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    function dataUrlToBlob(dataUrl) {
      const parts = dataUrl.split(",");
      const header = parts[0];
      const base64 = parts[1];
      const match = /data:(.*?);base64/.exec(header);
      const mime = match ? match[1] : "application/octet-stream";
      const bytes = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
      return new Blob([bytes], { type: mime });
    }

    async function copyImage(entry) {
      const src = entry.dataUrl || entry.objectUrl;
      if (!src) {
        flashToast("No image data", "");
        return;
      }
      if (!navigator.clipboard || !navigator.clipboard.write) {
        flashToast("Clipboard write unavailable", "Download instead");
        return;
      }
      try {
        const blob = entry.dataUrl ? dataUrlToBlob(entry.dataUrl) : await fetch(entry.objectUrl).then((r) => r.blob());
        await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
        flashToast("Image copied", entry.mime || "");
      } catch (error) {
        flashToast("Copy failed", "Downloading instead");
        downloadEntry(entry);
      }
    }

    function downloadEntry(entry) {
      const kind = entry.kind || "text";
      if (kind === "image") {
        const src = entry.dataUrl || entry.objectUrl;
        if (!src) {
          flashToast("No image to download", "");
          return;
        }
        const a = document.createElement("a");
        a.href = src;
        a.download = "clipboard-image";
        document.body.appendChild(a);
        a.click();
        a.remove();
        flashToast("Download started", "");
        return;
      }
      const text = entry.raw || "";
      const blob = new Blob([text], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "clipboard-text.txt";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      flashToast("Download started", "");
    }

    function cleanupEntry(entry) {
      if (entry && entry.objectUrl) {
        URL.revokeObjectURL(entry.objectUrl);
      }
    }

    function storageAvailable() {
      try {
        const key = "__clipboard-magic-test__";
        localStorage.setItem(key, "1");
        localStorage.removeItem(key);
        return true;
      } catch (error) {
        return false;
      }
    }

    function markStorageIssue() {
      storageOk = false;
      updateStorageChip();
      if (!storageWarned) {
        flashToast("Storage blocked", "Entries stay in memory for this session");
        storageWarned = true;
      }
    }

    init();

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden && autoTimer) {
        captureClipboard({ source: "auto", force: true });
      }
    });
  </script>
</body>
</html>
